{"ast":null,"code":"var getSpikesFromAccelerometer = function getSpikesFromAccelerometer(_ref) {\n  var recentAccelerationData = _ref.recentAccelerationData,\n      threshold = _ref.threshold,\n      previousValue = _ref.previousValue,\n      previousHighPointTime = _ref.previousHighPointTime,\n      wasGoingUp = _ref.wasGoingUp;\n  console.log(\"Spike Calculator Called\");\n  var overThresholdSpikes = [];\n  var goingUp = wasGoingUp;\n\n  if (previousHighPointTime === 0) {\n    previousHighPointTime = recentAccelerationData[0].time;\n  }\n\n  recentAccelerationData.forEach(function (accelerationDatum) {\n    if (accelerationDatum.value > previousValue && previousValue != 0) {\n      goingUp = true;\n      console.log(\"Going UP: \" + goingUp);\n      console.log(\"Previous Value: \" + previousValue);\n      console.log(\"Value: \" + accelerationDatum.value);\n    } else {\n      if (goingUp === true && (accelerationDatum.time - previousHighPointTime > 600 || previousHighPointTime == 0) && previousValue > threshold) {\n        console.log(\"Found spike!\");\n        overThresholdSpikes.push(accelerationDatum);\n        previousHighPointTime = accelerationDatum.time;\n      }\n\n      goingUp = false;\n      console.log(\"Previous Value: \" + previousValue);\n      console.log(\"Value: \" + accelerationDatum.value);\n    }\n\n    previousValue = accelerationDatum.value;\n  });\n  console.log(\"Spike Count: \" + overThresholdSpikes.length);\n  return {\n    spikes: overThresholdSpikes,\n    previousHighPointTime: previousHighPointTime,\n    wasGoingUp: goingUp\n  };\n};\n\nexport default getSpikesFromAccelerometer;","map":{"version":3,"names":["getSpikesFromAccelerometer","recentAccelerationData","threshold","previousValue","previousHighPointTime","wasGoingUp","console","log","overThresholdSpikes","goingUp","time","forEach","accelerationDatum","value","push","length","spikes"],"sources":["/Users/yagosampaio/Documents/GitHub/stedi-react-native/utils/StepCalculator.js"],"sourcesContent":["const getSpikesFromAccelerometer = ({recentAccelerationData, threshold, previousValue, previousHighPointTime, wasGoingUp}) =>{\n    console.log(\"Spike Calculator Called\");\n    const overThresholdSpikes = [];//the acceleration data, often look like the following, can you find the spike(s) over the default threshold\n/*\n[\n{\"value\": 9.88,\n\"time\": 1289182498},\n{\"value\": 9.89,\n\"time\": 1289182898},\n{\"value\": 9.88,\n\"time\": 1289183498},\n{\"value\": 10.01,\n\"time\": 1289184498},\n{\"value\": 11.03,\n\"time\": 1289185498},\n{\"value\": 12.45,\n\"time\": 1289186498},\n{\"value\": 11.99,\n\"time\": 1289187498},\n{\"value\": 11.88,\n\"time\": 1289188498}\n]\n     _______\n    | 9.88  |\n     -------\n    | 9.89  |\n     -------\n    | 10.01 |\n     -------\n    | 11.03 |\n     -------\n    | 12.45 |\n     -------\n    | 11.99 |\n     -------\n    | 11.88 |\n     -------\n    | 10.33 |\n     -------\n     */\n\n    let goingUp=wasGoingUp;//when we stop going up, we have hit a spike\n    //let previousValue = 0;//this is not a real value\n    if (previousHighPointTime===0){//this should only happen the first time this function is called during an exercise, since we have no spikes yet\n        previousHighPointTime=recentAccelerationData[0].time;//just assume the timestamp of the first sensor reading is good enough to compare with for noise elimination\n    }\n    recentAccelerationData.forEach((accelerationDatum) => {\n\n        if (accelerationDatum.value > previousValue && previousValue!=0){\n            goingUp = true;\n            console.log(\"Going UP: \"+goingUp );\n            console.log(\"Previous Value: \"+previousValue);\n            console.log(\"Value: \"+accelerationDatum.value);\n        } else {\n            if (goingUp===true && (accelerationDatum.time-previousHighPointTime > 600 || previousHighPointTime==0) && previousValue > threshold){\n                console.log(\"Found spike!\");\n                overThresholdSpikes.push(accelerationDatum);\n                previousHighPointTime = accelerationDatum.time;\n            }\n            goingUp = false;\n            console.log(\"Previous Value: \"+previousValue);\n            console.log(\"Value: \"+accelerationDatum.value);\n\n        }       \n        previousValue = accelerationDatum.value;\n    });\n\n    console.log(\"Spike Count: \"+overThresholdSpikes.length);\n    return {spikes: overThresholdSpikes, previousHighPointTime, wasGoingUp:goingUp};\n\n}\n\nexport default getSpikesFromAccelerometer;"],"mappings":"AAAA,IAAMA,0BAA0B,GAAG,SAA7BA,0BAA6B,OAA0F;EAAA,IAAxFC,sBAAwF,QAAxFA,sBAAwF;EAAA,IAAhEC,SAAgE,QAAhEA,SAAgE;EAAA,IAArDC,aAAqD,QAArDA,aAAqD;EAAA,IAAtCC,qBAAsC,QAAtCA,qBAAsC;EAAA,IAAfC,UAAe,QAAfA,UAAe;EACzHC,OAAO,CAACC,GAAR,CAAY,yBAAZ;EACA,IAAMC,mBAAmB,GAAG,EAA5B;EAuCA,IAAIC,OAAO,GAACJ,UAAZ;;EAEA,IAAID,qBAAqB,KAAG,CAA5B,EAA8B;IAC1BA,qBAAqB,GAACH,sBAAsB,CAAC,CAAD,CAAtB,CAA0BS,IAAhD;EACH;;EACDT,sBAAsB,CAACU,OAAvB,CAA+B,UAACC,iBAAD,EAAuB;IAElD,IAAIA,iBAAiB,CAACC,KAAlB,GAA0BV,aAA1B,IAA2CA,aAAa,IAAE,CAA9D,EAAgE;MAC5DM,OAAO,GAAG,IAAV;MACAH,OAAO,CAACC,GAAR,CAAY,eAAaE,OAAzB;MACAH,OAAO,CAACC,GAAR,CAAY,qBAAmBJ,aAA/B;MACAG,OAAO,CAACC,GAAR,CAAY,YAAUK,iBAAiB,CAACC,KAAxC;IACH,CALD,MAKO;MACH,IAAIJ,OAAO,KAAG,IAAV,KAAmBG,iBAAiB,CAACF,IAAlB,GAAuBN,qBAAvB,GAA+C,GAA/C,IAAsDA,qBAAqB,IAAE,CAAhG,KAAsGD,aAAa,GAAGD,SAA1H,EAAoI;QAChII,OAAO,CAACC,GAAR,CAAY,cAAZ;QACAC,mBAAmB,CAACM,IAApB,CAAyBF,iBAAzB;QACAR,qBAAqB,GAAGQ,iBAAiB,CAACF,IAA1C;MACH;;MACDD,OAAO,GAAG,KAAV;MACAH,OAAO,CAACC,GAAR,CAAY,qBAAmBJ,aAA/B;MACAG,OAAO,CAACC,GAAR,CAAY,YAAUK,iBAAiB,CAACC,KAAxC;IAEH;;IACDV,aAAa,GAAGS,iBAAiB,CAACC,KAAlC;EACH,CAnBD;EAqBAP,OAAO,CAACC,GAAR,CAAY,kBAAgBC,mBAAmB,CAACO,MAAhD;EACA,OAAO;IAACC,MAAM,EAAER,mBAAT;IAA8BJ,qBAAqB,EAArBA,qBAA9B;IAAqDC,UAAU,EAACI;EAAhE,CAAP;AAEH,CAtED;;AAwEA,eAAeT,0BAAf"},"metadata":{},"sourceType":"module"}